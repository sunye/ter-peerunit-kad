*#summary Le rapport de groupe

(autres) Idées en vrac :

= Contexte =
  * Présentation du laboratoire (si ce rapport est diffusé un minimum)
    * importance du labo (nb chercheurs, liens avec d'autres labo, cnrs..)
    * principaux axes de recherche.. (tout ça en concis)
  * Présentation de l'équipe

Le Master 1 ALMA intègre un module d'Initiation à la Recherche. Dans le cadre de ce module, nous avons choisi de rejoindre l'équipe Atlas-GDD du Laboratoire d'Informatique de Nantes Atlantique.

Dates importantes pour le LINA:

      2004: Création du laboratoire comme résultat du rapprochement de L'IRIN institut    de recherche en informatique de Nantes et du département informatique de l'école des mines de Nantes.
            Reconnu comme FRE (formation de recherche en evolution) et reconduit en 2006
      2008: le LINA devient UMR

L'équipe Atlas Gestion de Données Distribuées mène des recherches sur les applications réparties et les problèmatiques inhérentes : 
  * Table de hachage distribuées
  * Sécurité, confidentialité
  * à compléter

Tout au long de cette initiation, nous avions deux objectifs :
  * mener un projet en rapport avec les outils et les technologies qui ont cours dans l'équipe
  * s'intégrer dans l'équipe afin d'avoir un regard sur le travail de chercheur et l'organisation du laboratoire.

Nous avons consacré à cette initiation un jour par semaine, le jeudi ainsi que quelques heures le reste de la semaine en fonction de nos disponibilités.

== Présentation du projet ==

Nous avons travaillé sur un sujet proposé par Gerson Sunyé qui travaille au sein d'Atlas-GDD et, plus particulièrement sur la qualité logicielle.

L'objectif de notre projet était de tester un système pair-à-pair. Le test devaient être menés à l'aide de l'outil PeerUnit. PeerUnit est un framework permettant de réaliser des tests unitaires répartis. PeerUnit est un projet encore expérimental, il a été principalement développé par Eduardo Almeida pour sa thèse encadrée par Gerson Sunyé et qui prit fin au cour du semestre.

La technologie à tester n'était pas déterminée dans le sujet bien que le projet OceanStore de l'université de UC Berkley était donné comme exemple de sujet possible. Après quelques difficultés, nous avons finalement testé une implémentation du protocole Kademlia.

= Partie 2 =

== Choix d'une technologie à tester ==

Lorsque nous nous sommes lancés sur le projet, notre objectif premier était de tester OceanStore. Nous avons passé plusieurs semaines à étudier son fonctionnement et son utilisation. La complexité de l'application (4 couches différentes et trop configurables, si bien que les auteurs avaient recours à des dizaines de scripts Perl pour lancer le tout...) ainsi que le manque de documentation utilisateur (une Javadoc était toutefois disponible) nous ont conduit, après plusieurs semaines d'essais infructueux à renoncer à l'idée de tester OceanStore.

Nous avons dès lors convenu, avec les encadrants, de changer de technologie. Nous nous sommes alors tournés vers le protocole Kademlia : un protocole récent très utilisé dans les applications pair-à-pair à grande échelle (notamment eMule, et Azureus : deux des principales applications pair à pair utilisées par le grand public pour le partage de fichier).

Dans un premier temps, nous nous pencher sur Arureus : eMule est écrit en C++ tandis que Azureus est en Java. PeerUnit étant en Java, il ne permet pas de tester une application C++ sans ajout fonctionnel profond. Nous nous sommes donc tourner vers Azureus.

Après un examen rapide des sources de Azureus (quelques 4000 classes majoritairement non-documentées), nous avons trouvé la partie chargée de gérer la DHT basée sur Kademlia. Malheureusement, l'architecture de l'application (pas de découplage entre l'implémentation du protocole et son utilisation, type des valeurs de la DHT fixé statiquement) ne fournissait pas de point d'entrée adéquat pour pouvoir travailler avec PeerUnit dans de bonnes conditions.

Nous nous sommes donc lancés à la recherche d'autres implémentation de Kademlia : c'est ainsi que nous avons découvert un projet de l'université de Copenhague baptisée PlanX. Notre choix c'est arrêté sur ce dernier : malheureusement, nous avions déjà perdu plusieurs semaines à essayer d'utiliser les implémentations décrites précédemment.

== OceanStrore ==

Étant donné le temps qu'on y a passé, expliquer ce qui va pas

== Azureus ==

Pareil

== Plan-X ==

Plan-X est un projet de stockage persistant et distribué de documents XML mené à l'université de Compenhague par différents intervenants. Parmi eux, Thomas Ambus a œuvré à l'implémentation d'une couche Kademlia pour ce projet (un autre de ses projets est de créer une interface permettant d'obtenir des ressources à partir d'une requête XPath).

http://plan-x.org/xmlstore/

http://www.thomas.ambus.dk/plan-x/

Avant de découvrir Plan-X, nous étions inquiet quant à l'issue du projet. Cette nouvelle perspective nous a permis de reprendre nos travaux sur des bases saines.

== Kademlia ==

Décrire brièvement mais formellement le protocole (~ 1 page)

  * Kademlia
    * différences avec les autres DHT
      * Utilisation du protocole UDP
      * Nombre reduit de messages de configuration
      * Requêtes envoyées de façon parallèles et non synchronisées
    * Usage (Ocean Store/Vuze/eMule?->plus connu)
      * ~~semble être utilisé principalement pour la localisation de donnée et non leur transfert.. (J'ai loupé quelque chose ?) → ouais, c'est le cas de toutes les DHT~~ 
    * description du protocole/fonctionnement
      * ID sur 160 bits,
      * connexion au réseau,
      * notion de distance avec un XOR
      * mécanisme de recherche...
      * protocole décentralisé

== PeerUnit ==



= Partie 3 et plus =
  * Test effectués...
  * Problèmes rencontrés

=Test1=
récupération de valeur avec 2 noeuds
  * Connection d'un peer au reseau
  * Le peer met une valeur
  * un deuxième peer se connecte au précedent
  * il essaye de récupérer la valeur
  * il recoit la bonne valeur

=Test2=
Récuperation de valeur avec 8 noeuds
  * Connection d'un peer au reseau
  * Le peer met une valeur
  * huit autres peers se connectent au précedent
  * ils essayent de récupérer la valeur
  * ils recoivent la bonne valeur

=Test3=
Test pour voir si le mappage est éffectuer au nouveau noeud connecté
  * Connection d'un peer au reseau
  * trois autres peers se connectent au premier connecté
  * le deuxième peer connecté met une valeur
  * quatre autres peer se connectent au premier
  * normalement au vue de la configuration du reseau seulement le mappage des valeur est effectué au premier peer rejoint
  * les quatres premiers peers se déconnectent
  * le cinquième peer qui doit avoir une recopie du mappage fait un get de la valeur le test sur la valeur reussi
  * ensuite il se déconnecte
  * les peers 6,7 et 8 essayent de récuperer la valeur mais ils tombent sur une valeur "null"
  * le test est alors réussi

=Test4=
Test pour voir si le mapping est bien effectuer pour K noeud et si k-1 noeud se déconnecte
  * Connection du premier peer
  * Connection de 7 autres le deuxième se connecte au premier, le troisième au deuxième ...(topologie bus)
  * Le noeud 2 publie un valeur
  * Le noeud 1 et 2 se déconnectent (le mapping doit être copié dans le noeud 3 et 4 car le reseau est ainsi configuré)
  * le noeud 3 se déconnecte
  * le noeud 4 essaye de recuperer la valeur.
  * Il y arrive
  * Le test est alors réussi

=Test5=
Ce test consiste à voir si un noeud peut ne poster qu'une seul valeur  
  * Le premier noeud se connecte
  * il poste deux valeur
  * un deuxième noeud se connecte au précedent
  * le premier noeud essaye de recupérer la première valeur qu'il a posté
  * il réussit
  * il essaye ensuite de récuperer la deuxième valeur
  * il échoue
  * test réussi
*Ne pas hésiter à compléter/détailler (cliquez sur Edit this page ↑↑↑) *